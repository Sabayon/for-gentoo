From b282d53797440153d913f731524f0653fdfd570b Mon Sep 17 00:00:00 2001
From: Antti Ajanki <antti.ajanki@iki.fi>
Date: Thu, 21 Mar 2013 18:02:48 +0200
Subject: [PATCH 001/110] Split-off caching functionality from Downloader into
 separate classes

---
 src/CMakeLists.txt                           |   1 +
 src/backends/netutils.cpp                    | 629 +++------------------------
 src/backends/netutils.h                      | 120 ++---
 src/backends/rtmputils.cpp                   |   6 +-
 src/backends/rtmputils.h                     |   3 +-
 src/backends/security.cpp                    |   6 +-
 src/backends/streamcache.cpp                 | 494 +++++++++++++++++++++
 src/backends/streamcache.h                   | 197 +++++++++
 src/compat.h                                 |   1 +
 src/plugin/plugin.cpp                        |  37 +-
 src/plugin/plugin.h                          |  12 +-
 src/scripting/flash/display/flashdisplay.cpp |  22 +-
 src/scripting/flash/media/flashmedia.cpp     |  23 +-
 src/scripting/flash/media/flashmedia.h       |   7 +-
 src/scripting/flash/net/URLStream.cpp        |   9 +-
 src/scripting/flash/net/flashnet.cpp         |  36 +-
 16 files changed, 867 insertions(+), 736 deletions(-)
 create mode 100644 src/backends/streamcache.cpp
 create mode 100644 src/backends/streamcache.h

diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index e86fb44..79a2213 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -47,6 +47,7 @@ SET(LIBSPARK_SOURCES
   backends/rendering_context.cpp
   backends/rtmputils.cpp
   backends/security.cpp
+  backends/streamcache.cpp
   backends/urlutils.cpp
   backends/xml_support.cpp
   parsing/amf3_generator.cpp
diff --git a/src/backends/netutils.cpp b/src/backends/netutils.cpp
index 408c14b..1c397aa 100644
--- a/src/backends/netutils.cpp
+++ b/src/backends/netutils.cpp
@@ -24,6 +24,7 @@
 #include "backends/config.h"
 #include "backends/netutils.h"
 #include "backends/rtmputils.h"
+#include "backends/streamcache.h"
 #include "compat.h"
 #include <string>
 #include <algorithm>
@@ -165,25 +166,26 @@ StandaloneDownloadManager::~StandaloneDownloadManager()
  * \return A pointer to a newly created \c Downloader for the given URL.
  * \see DownloadManager::destroy()
  */
-Downloader* StandaloneDownloadManager::download(const URLInfo& url, bool cached, ILoadable* owner)
+Downloader* StandaloneDownloadManager::download(const URLInfo& url, _R<StreamCache> cache, ILoadable* owner)
 {
+	bool cached = dynamic_cast<FileStreamCache *>(cache.getPtr()) != NULL;
 	LOG(LOG_INFO, _("NET: STANDALONE: DownloadManager::download '") << url.getParsedURL()
 			<< "'" << (cached ? _(" - cached") : ""));
 	ThreadedDownloader* downloader;
 	if(url.getProtocol() == "file")
 	{
 		LOG(LOG_INFO, _("NET: STANDALONE: DownloadManager: local file"));
-		downloader=new LocalDownloader(url.getPath(), cached, owner);
+		downloader=new LocalDownloader(url.getPath(), cache, owner);
 	}
 	else if(url.getProtocol().substr(0, 4) == "rtmp")
 	{
 		LOG(LOG_INFO, _("NET: STANDALONE: DownloadManager: RTMP stream"));
-		downloader=new RTMPDownloader(url.getParsedURL(), url.getStream(), owner);
+		downloader=new RTMPDownloader(url.getParsedURL(), cache, url.getStream(), owner);
 	}
 	else
 	{
 		LOG(LOG_INFO, _("NET: STANDALONE: DownloadManager: remote file"));
-		downloader=new CurlDownloader(url.getParsedURL(), cached, owner);
+		downloader=new CurlDownloader(url.getParsedURL(), cache, owner);
 	}
 	downloader->enableFencingWaiting();
 	addDownloader(downloader);
@@ -201,7 +203,8 @@ Downloader* StandaloneDownloadManager::download(const URLInfo& url, bool cached,
  * \return A pointer to a newly created \c Downloader for the given URL.
  * \see DownloadManager::destroy()
  */
-Downloader* StandaloneDownloadManager::downloadWithData(const URLInfo& url, const std::vector<uint8_t>& data,
+Downloader* StandaloneDownloadManager::downloadWithData(const URLInfo& url, _R<StreamCache> cache, 
+		const std::vector<uint8_t>& data,
 		const std::list<tiny_string>& headers, ILoadable* owner)
 {
 	LOG(LOG_INFO, _("NET: STANDALONE: DownloadManager::downloadWithData '") << url.getParsedURL());
@@ -209,14 +212,14 @@ Downloader* StandaloneDownloadManager::downloadWithData(const URLInfo& url, cons
 	if(url.getProtocol() == "file")
 	{
 		LOG(LOG_INFO, _("NET: STANDALONE: DownloadManager: local file - Ignoring data field"));
-		downloader=new LocalDownloader(url.getPath(), false, owner);
+		downloader=new LocalDownloader(url.getPath(), cache, owner);
 	}
 	else if(url.getProtocol() == "rtmpe")
 		throw RunTimeException("RTMPE does not support additional data");
 	else
 	{
 		LOG(LOG_INFO, _("NET: STANDALONE: DownloadManager: remote file"));
-		downloader=new CurlDownloader(url.getParsedURL(), data, headers, owner);
+		downloader=new CurlDownloader(url.getParsedURL(), cache, data, headers, owner);
 	}
 	downloader->enableFencingWaiting();
 	addDownloader(downloader);
@@ -229,20 +232,15 @@ Downloader* StandaloneDownloadManager::downloadWithData(const URLInfo& url, cons
  *
  * Constructor for the Downloader class. Can only be called from derived classes.
  * \param[in] _url The URL for the Downloader.
- * \param[in] _cached Whether or not to cache this download.
+ * \param[in] _cache StreamCache instance for caching this download.
  */
-Downloader::Downloader(const tiny_string& _url, bool _cached, ILoadable* o):
-	cacheOpened(0),dataAvailable(0),terminated(0),hasTerminated(false),cacheHasOpened(false), //LOCKING
-	waitingForCache(false),waitingForData(false),waitingForTermination(false), //STATUS
-	forceStop(true),failed(false),finished(false),                //FLAGS
+Downloader::Downloader(const tiny_string& _url, _R<StreamCache> _cache, ILoadable* o):
 	url(_url),originalURL(url),                                   //PROPERTIES
-	buffer(NULL),stableBuffer(NULL),                              //BUFFERING
+	cache(_cache),                                                //CACHING
 	owner(o),                                                     //PROGRESS
-	cachePos(0),cacheSize(0),keepCache(false),cached(_cached),    //CACHING
 	redirected(false),requestStatus(0),                           //HTTP REDIR, STATUS & HEADERS
-	length(0),receivedLength(0)                                   //DOWNLOADED DATA
+	length(0)                                                     //DOWNLOADED DATA
 {
-	setg(NULL,NULL,NULL);
 }
 
 /**
@@ -252,18 +250,13 @@ Downloader::Downloader(const tiny_string& _url, bool _cached, ILoadable* o):
  * \param[in] _url The URL for the Downloader.
  * \param[in] data Additional data to send to the host
  */
-Downloader::Downloader(const tiny_string& _url, const std::vector<uint8_t>& _data, const std::list<tiny_string>& h, ILoadable* o):
-	cacheOpened(0),dataAvailable(0),terminated(0),hasTerminated(false),cacheHasOpened(false), //LOCKING
-	waitingForCache(false),waitingForData(false),waitingForTermination(false), //STATUS
-	forceStop(true),failed(false),finished(false),                   //FLAGS
+Downloader::Downloader(const tiny_string& _url, _R<StreamCache> _cache, const std::vector<uint8_t>& _data, const std::list<tiny_string>& h, ILoadable* o):
 	url(_url),originalURL(url),                                      //PROPERTIES
-	buffer(NULL),stableBuffer(NULL),                                 //BUFFERING
+	cache(_cache),                                                   //CACHING
 	owner(o),                                                        //PROGRESS
-	cachePos(0),cacheSize(0),keepCache(false),cached(false),         //CACHING
 	redirected(false),requestStatus(0),requestHeaders(h),data(_data),//HTTP REDIR, STATUS & HEADERS
-	length(0),receivedLength(0)                                      //DOWNLOADED DATA
+	length(0)                                                        //DOWNLOADED DATA
 {
-	setg(NULL,NULL,NULL);
 }
 
 /**
@@ -275,263 +268,6 @@ Downloader::Downloader(const tiny_string& _url, const std::vector<uint8_t>& _dat
  */
 Downloader::~Downloader()
 {
-	waitForTermination();
-
-	Mutex::Lock l(mutex);
-
-	if(cached)
-	{
-		if(cache.is_open())
-			cache.close();
-		if(!keepCache && cacheFilename != "")
-			unlink(cacheFilename.raw_buf());
-	}
-	if(buffer != NULL)
-	{
-		free(buffer);
-	}
-	if(stableBuffer != NULL && stableBuffer!=buffer)
-	{
-		free(stableBuffer);
-	}
-}
-
-/**
- * \brief Called by the streambuf API
- *
- * Called by the streambuf API when there is no more data to read.
- * Waits for the mutex at start and releases the mutex when finished.
- * \throw RunTimeException Cache file could not be read
- */
-Downloader::int_type Downloader::underflow()
-{
-	Mutex::Lock l(mutex);
-	//Let's see if the other buffer contains new data
-	syncBuffers();
-	if(egptr()-gptr()>0)
-	{
-		//There is data already
-		return *(uint8_t*)gptr();
-	}
-	const unsigned int startOffset=getOffset();
-	const unsigned int startReceivedLength=receivedLength;
-	assert(startOffset<=startReceivedLength);
-	//If we have read all available data
-	if(startReceivedLength==startOffset)
-	{
-		//The download has failed or has finished
-		if(failed || finished)
-			return EOF;
-		//We haven't reached the end of the download, more bytes should follow
-		else
-		{
-			waitForData_locked();
-			syncBuffers();
-
-			//Check if we haven't failed or finished (and there wasn't any new data)
-			if(failed || (finished && startReceivedLength==receivedLength))
-				return EOF;
-		}
-	}
-
-	//We should have an initialized buffer here since there is some data
-	assert_and_throw(buffer != NULL);
-	//Temporary pointers to new streambuf read positions
-	char* begin;
-	char* cur;
-	char* end;
-	//Index in the buffer pointing to the data to be returned
-	uint32_t index;
-
-	if(cached)
-	{
-		waitForCache();
-
-		size_t newCacheSize = receivedLength-(cachePos+cacheSize);
-		if(newCacheSize > cacheMaxSize)
-			newCacheSize = cacheMaxSize;
-
-		//Move the start of our new window to the end of our last window
-		cachePos = cachePos+cacheSize;
-		cacheSize = newCacheSize;
-		//Seek to the start of our new window
-		cache.seekg(cachePos);
-		//Read into our buffer window
-		cache.read((char*)stableBuffer, cacheSize);
-		if(cache.fail())
-		{
-			throw RunTimeException(_("Downloader::underflow: reading from cache file failed"));
-		}
-
-		begin=(char*)stableBuffer;
-		cur=(char*)stableBuffer;
-		end=(char*)stableBuffer+cacheSize;
-		index=0;
-
-	}
-	else
-	{
-		begin=(char*)stableBuffer;
-		cur=(char*)stableBuffer+startOffset;
-		end=(char*)stableBuffer+receivedLength;
-		index=startOffset;
-	}
-
-	//If we've failed, don't bother any more
-	if(failed)
-		return EOF;
-
-	//Set our new iterators in the buffer (begin, cursor, end)
-	setg(begin, cur, end);
-
-	//Cast to unsigned, otherwise 0xff would become eof
-	return (unsigned char)stableBuffer[index];
-}
-
-/**
-  * Internal function to synchronize oldBuffer and buffer
-  *
-  * \pre Must be called from a function called by the streambuf API
-  */
-void Downloader::syncBuffers()
-{
-	if(stableBuffer!=buffer)
-	{
-		//The buffer have been changed
-		free(stableBuffer);
-		stableBuffer=buffer;
-		//Remember the relative positions of the input pointers
-		intptr_t curPos = (intptr_t) (gptr()-eback());
-		intptr_t curLen = (intptr_t) (egptr()-eback());
-		//Do some pointer arithmetic to point the input pointers to the right places in the new buffer
-		setg((char*)stableBuffer,(char*)(stableBuffer+curPos),(char*)(stableBuffer+curLen));
-	}
-}
-
-/**
- * \brief Called by the streambuf API
- *
- * Called by the streambuf API to seek to an absolute position
- * Mutex must be locked on entry.
- * \throw RunTimeException Cache file could not be read
- */
-Downloader::pos_type Downloader::seekpos(pos_type pos, std::ios_base::openmode mode)
-{
-	assert_and_throw(mode==std::ios_base::in);
-	assert_and_throw(buffer && stableBuffer);
-
-	syncBuffers();
-
-	// read from stream until we have enough data
-	uint32_t tmplen = receivedLength;
-	while (!hasTerminated && pos > receivedLength) 
-	{
-		waitForData_locked();
-		syncBuffers();
-		if (tmplen == receivedLength)
-			break; // no new data read
-		tmplen = receivedLength;
-	}
-	
-	if(cached)
-	{
-		waitForCache();
-
-		//The requested position is inside our current window
-		if(pos >= cachePos && pos <= cachePos+cacheSize)
-		{
-			//Just move our cursor to the correct position in our window
-			setg((char*)stableBuffer, (char*)stableBuffer+pos-cachePos, (char*)stableBuffer+cacheSize);
-		}
-		//The requested position is outside our current window
-		else if(pos <= receivedLength)
-		{
-			cachePos = pos;
-			cacheSize = receivedLength-pos;
-			if(cacheSize > cacheMaxSize)
-				cacheSize = cacheMaxSize;
-
-			//Seek to the requested position
-			cache.seekg(cachePos);
-			//Read into our window
-			cache.read((char*)stableBuffer, cacheSize);
-			if(cache.fail())
-				throw RunTimeException(_("Downloader::seekpos: reading from cache file failed"));
-
-			//Our window starts at position pos
-			setg((char*) stableBuffer, (char*) stableBuffer, ((char*) stableBuffer)+cacheSize);
-		}
-		//The requested position is bigger then our current amount of available data
-		else if(pos > receivedLength)
-			return -1;
-	}
-	else
-	{
-		//The requested position is valid
-		if(pos <= receivedLength)
-			setg((char*)stableBuffer,(char*)stableBuffer+pos,(char*)stableBuffer+receivedLength);
-		//The requested position is bigger then our current amount of available data
-		else
-			return -1;
-	}
-
-	return pos;
-}
-
-/**
- * \brief Called by the streambuf API
- *
- * Called by the streambuf API to seek to a relative position
- * Waits for the mutex at start and releases the mutex when finished.
- */
-Downloader::pos_type Downloader::seekoff(off_type off, std::ios_base::seekdir dir, std::ios_base::openmode mode)
-{
-	assert_and_throw(mode==std::ios_base::in);
-	assert_and_throw(buffer != NULL);
-
-	Mutex::Lock l(mutex);
-	if (off != 0)
-	{
-		switch (dir)
-		{
-			case std::ios_base::beg:
-				seekpos(off,mode);
-				break;
-			case std::ios_base::cur:
-			{
-				pos_type tmp = getOffset();
-				seekpos(tmp+off,mode);
-				break;
-			}
-			case std::ios_base::end:
-				l.release();
-				waitForTermination();
-				l.acquire();
-				if (finished)
-					seekpos(length+off,mode);
-				break;
-			default:
-				break;
-		}
-	}
-
-	return getOffset();
-}
-
-/**
- * \brief Get the position of the read cursor in the (virtual) downloaded data
- *
- * Get the position of the read cursor in the (virtual) downloaded data.
- * If downloading to memory this method returns the position of the read cursor in the buffer.
- * If downloading to a cache file, this method returns the position of the read cursor in the buffer
- * + the position of the buffer window into the cache file.
- */
-Downloader::pos_type Downloader::getOffset() const
-{
-	pos_type ret = gptr()-eback();
-	if(cached)
-		ret+=cachePos;
-	return ret;
 }
 
 /**
@@ -541,28 +277,13 @@ Downloader::pos_type Downloader::getOffset() const
  * signals \c dataAvailable if it is being waited for.
  * It also signals \c terminated to mark the end of the download.
  * A download should finish be either calling \c setFailed() or \c setFinished(), not both.
- * \post \c failed == \c true & \c finished == \c true
  * \post \c length == \c receivedLength
- * \post Signals \c dataAvailable if it is being waited for (\c waitingForData == \c true). 
- * \post \c waitingForTermination == \c false
- * \post Signals \c terminated
  */
 void Downloader::setFailed()
 {
-	failed=true;
-	finished = true;
+	cache->markFinished(true);
 	//Set the final length
-	length = receivedLength;
-
-	//If we are waiting for data to become available, signal dataAvailable
-	if(waitingForData)
-	{
-		waitingForData = false;
-		dataAvailable.signal();
-	}
-
-	waitingForTermination = false;
-	terminated.signal();
+	length = cache->getReceivedLength();
 }
 
 /**
@@ -572,139 +293,13 @@ void Downloader::setFailed()
  * signals \c dataAvailable if it is being waited for.
  * It also signals \c terminated to mark the end of the download.
  * A download should finish be either calling \c setFailed() or \c setFinished(), not both.
- * \post \c finished == \ctrue
  * \post \c length == \c receivedLength
- * \post Signals \c dataAvailable if it is being waited for (\c waitingForData == true).
- * \post \c waitingForTermination == \c false
- * \post Signals \c terminated
  */
 void Downloader::setFinished()
 {
-	finished=true;
+	cache->markFinished();
 	//Set the final length
-	length = receivedLength;
-
-	//If we are waiting for data to become available, signal dataAvailable
-	if(waitingForData)
-	{
-		waitingForData = false;
-		dataAvailable.signal();
-	}
-
-	waitingForTermination = false;
-	terminated.signal();
-}
-
-/**
- * \brief (Re)allocates the buffer
- *
- * (Re)allocates the buffer to a given size
- * Waits for mutex at start and releases mutex when finished.
- * \post \c buffer is (re)allocated
- * mutex must be locked on entry
- */
-void Downloader::allocateBuffer(size_t size)
-{
-	//Create buffer
-	if(buffer == NULL)
-	{
-		buffer = (uint8_t*) calloc(size, sizeof(uint8_t));
-		stableBuffer = buffer;
-		setg((char*)buffer,(char*)buffer,(char*)buffer);
-	}
-	//If the buffer already exists, reallocate
-	else
-	{
-		assert(!cached);
-		intptr_t curLen = receivedLength;
-		//We have to extend the buffer, so create a new one
-		if(stableBuffer!=buffer)
-		{
-			//We're already filling a different buffer from the one used to read
-			//Extend it!
-			buffer = (uint8_t*)realloc(buffer,size);
-		}
-		else
-		{
-			//Create a different buffer
-			buffer = (uint8_t*) calloc(size, sizeof(uint8_t));
-			//Copy the stableBuffer into this
-			memcpy(buffer,stableBuffer,curLen);
-		}
-		//Synchronization of the buffers will be done at the first chance
-	}
-}
-
-/**
- * \brief Creates & opens a temporary cache file
- *
- * Creates a temporary cache file in /tmp and calls \c openExistingCache() with that file.
- * Waits for mutex at start and releases mutex when finished.
- * \throw RunTimeException Temporary file could not be created
- * \throw RunTimeException Called when the downloader isn't cached or when the cache is already open
- * \see Downloader::openExistingCache()
- * mutex must be hold prior calling
- */
-void Downloader::openCache()
-{
-	//Only act if the downloader is cached and the cache hasn't been opened yet
-	if(cached && !cache.is_open())
-	{
-		//Create a temporary file(name)
-		std::string cacheFilenameS = Config::getConfig()->getCacheDirectory() + "/" + Config::getConfig()->getCachePrefix() + "XXXXXX";
-		char* cacheFilenameC = g_newa(char,cacheFilenameS.length()+1);
-		strncpy(cacheFilenameC, cacheFilenameS.c_str(), cacheFilenameS.length());
-		cacheFilenameC[cacheFilenameS.length()] = '\0';
-		//char cacheFilenameC[30] = "/tmp/lightsparkdownloadXXXXXX";
-		//strcpy(cacheFilenameC, "/tmp/lightsparkdownloadXXXXXX");
-		int fd = g_mkstemp(cacheFilenameC);
-		if(fd == -1)
-			throw RunTimeException(_("Downloader::openCache: cannot create temporary file"));
-		//We are using fstream to read/write to the cache, so we don't need this FD
-		close(fd);
-
-		//Let the openExistingCache function handle the rest
-		openExistingCache(tiny_string(cacheFilenameC, true));
-	}
-	else
-		throw RunTimeException(_("Downloader::openCache: downloader isn't cached or called twice"));
-}
-
-/**
- * \brief Opens an existing cache file
- *
- * Opens an existing cache file, allocates the buffer and signals \c cacheOpened.
- * Waits for mutex at start and releases mutex when finished.
- * \post \c cacheFilename is set
- * \post \c cache file is opened
- * \post \c buffer is initialized
- * \post \c cacheOpened is signalled
- * \throw RunTimeException File could not be opened
- * \throw RunTimeException Called when the downloader isn't cached or when the cache is already open
- * \see Downloader::allocateBuffer()
- * mutex must be hold on entering
- */
-void Downloader::openExistingCache(tiny_string filename)
-{
-	//Only act if the downloader is cached and the cache hasn't been opened yet
-	if(cached && !cache.is_open())
-	{
-		//Save the filename
-		cacheFilename = filename;
-
-		//Open the cache file
-		cache.open(cacheFilename.raw_buf(), std::fstream::binary | std::fstream::in | std::fstream::out);
-		if(!cache.is_open())
-			throw RunTimeException(_("Downloader::openCache: cannot open temporary cache file"));
-
-		allocateBuffer(cacheMaxSize);
-
-		LOG(LOG_INFO, _("NET: Downloading to cache file: ") << cacheFilename);
-
-		cacheOpened.signal();
-	}
-	else
-		throw RunTimeException(_("Downloader::openCache: downloader isn't cached or called twice"));
+	length = cache->getReceivedLength();
 }
 
 /**
@@ -712,27 +307,14 @@ void Downloader::openExistingCache(tiny_string filename)
  *
  * Sets the expected length of the download.
  * Can be called multiple times if the length isn't known up front (reallocating the buffer on the fly).
- * Waits for mutex at start and releases mutex when finished.
- * \post \c buffer is (re)allocated 
- * mutex must be hold prior calling
  */
 void Downloader::setLength(uint32_t _length)
 {
 	//Set the length
 	length=_length;
 
-	//The first call to this function should open the cache
-	if(cached)
-	{
-		if(!cache.is_open())
-			openCache();
-	}
-	else
-	{
-		if(buffer == NULL)
-			LOG(LOG_INFO, _("NET: Downloading to memory"));
-		allocateBuffer(length);
-	}
+	cache->reserve(length);
+
 	notifyOwnerAboutBytesTotal();
 }
 
@@ -752,39 +334,9 @@ void Downloader::append(uint8_t* buf, uint32_t added)
 	if(added==0)
 		return;
 
-	Mutex::Lock l(mutex);
-
-	//If the added data would overflow the buffer, grow it
-	if((receivedLength+added)>length)
-	{
-		uint32_t newLength;
-		assert(length>=receivedLength);
-		//If reallocating the buffer ask for a minimum amount of space
-		if((receivedLength+added)-length > bufferMinGrowth)
-			newLength = receivedLength + added;
-		else
-			newLength = length + bufferMinGrowth;
-		assert(newLength>=receivedLength+added);
-
-		setLength(newLength);
-	}
-
-	if(cached)
-	{
-		//Seek to where we last wrote data
-		cache.seekp(receivedLength);
-		cache.write((char*) buf, added);
-	}
-	else
-		memcpy(buffer+receivedLength, buf, added);
-
-	receivedLength += added;
-
-	if(waitingForData)
-	{
-		waitingForData = false;
-		dataAvailable.signal();
-	}
+	cache->append((unsigned char *)buf, added);
+	if (cache->getReceivedLength() > length)
+		setLength(cache->getReceivedLength());
 
 	notifyOwnerAboutBytesLoaded();
 }
@@ -824,8 +376,6 @@ void Downloader::parseHeaders(const char* _headers, bool _setLength)
  */
 void Downloader::parseHeader(std::string header, bool _setLength)
 {
-	Mutex::Lock l(mutex);
-
 	if(header.substr(0, 9) == "HTTP/1.1 " || header.substr(0, 9) == "HTTP/1.0 ") 
 	{
 		std::string status = header.substr(9, 3);
@@ -891,83 +441,8 @@ void Downloader::parseHeader(std::string header, bool _setLength)
  */
 void Downloader::stop()
 {
-	failed = true;
-	finished = true;
-	length = receivedLength;
-
-	waitingForData = false;
-	dataAvailable.signal();
-
-	waitingForTermination = false;
-	terminated.signal();
-}
-
-/**
- * \brief Wait for the cache file to be opened
- *
- * If \c !cacheHasOpened: wait for the \c cacheOpened signal and set \c cacheHasOpened to \c true
- * Waits for the mutex at start and releases the mutex when finished.
- * \post \c cacheOpened signals has been handled
- * \post \c cacheHasOpened = true
- * mutex must be locked on entry
- */
-void Downloader::waitForCache()
-{
-	if(!cacheHasOpened)
-	{
-		waitingForCache = true;
-
-		mutex.unlock();
-		cacheOpened.wait();
-		mutex.lock();
-
-		cacheHasOpened = true;
-	}
-}
-
-/**
- * \brief Wait for data to become available
- *
- * Wait for data to become available.
- * Waits for the mutex at start and releases the mutex when finished.
- * \post \c dataAvailable signal has been handled
- */
-void Downloader::waitForData_locked()
-{
-	waitingForData = true;
-	mutex.unlock();
-	dataAvailable.wait();
-	mutex.lock();
-}
-
-/**
- * \brief Wait for termination of the downloader
- *
- * If \c getSys()->isShuttingDown(), calls \c setFailed() and returns.
- * Otherwise if \c !hasTerminated: wait for the \c terminated signal and set \c hasTerminated to \c true
- * Waits for the mutex at start and releases the mutex when finished.
- * \post \c terminated signal has been handled
- * \post \c hasTerminated = true
- */
-void Downloader::waitForTermination()
-{
-	Mutex::Lock l(mutex);
-	if(getSys()->isShuttingDown())
-	{
-		setFailed();
-		return;
-	}
-
-	if(!hasTerminated)
-	{
-		waitingForTermination = true;
-
-		l.release();
-		terminated.wait();
-		l.acquire();
-
-		hasTerminated = true;
-	}
+	cache->markFinished(true);
+	length = cache->getReceivedLength();
 }
 
 void Downloader::notifyOwnerAboutBytesTotal() const
@@ -979,7 +454,7 @@ void Downloader::notifyOwnerAboutBytesTotal() const
 void Downloader::notifyOwnerAboutBytesLoaded() const
 {
 	if(owner)
-		owner->setBytesLoaded(receivedLength);
+		owner->setBytesLoaded(cache->getReceivedLength());
 }
 
 void ThreadedDownloader::enableFencingWaiting()
@@ -1010,8 +485,8 @@ void ThreadedDownloader::waitFencing()
  * \param[in] _url The URL for the Downloader.
  * \param[in] _cached Whether or not to cache this download.
  */
-ThreadedDownloader::ThreadedDownloader(const tiny_string& url, bool cached, ILoadable* o):
-	Downloader(url, cached, o),fenceState(false)
+ThreadedDownloader::ThreadedDownloader(const tiny_string& url, _R <StreamCache> cache, ILoadable* o):
+	Downloader(url, cache, o),fenceState(false)
 {
 }
 
@@ -1022,9 +497,10 @@ ThreadedDownloader::ThreadedDownloader(const tiny_string& url, bool cached, ILoa
  * \param[in] _url The URL for the Downloader.
  * \param[in] data Additional data to send to the host
  */
-ThreadedDownloader::ThreadedDownloader(const tiny_string& url, const std::vector<uint8_t>& data,
+ThreadedDownloader::ThreadedDownloader(const tiny_string& url, _R<StreamCache> cache,
+				       const std::vector<uint8_t>& data,
 				       const std::list<tiny_string>& headers, ILoadable* o):
-	Downloader(url, data, headers, o),fenceState(false)
+	Downloader(url, cache, data, headers, o),fenceState(false)
 {
 }
 
@@ -1046,8 +522,8 @@ ThreadedDownloader::~ThreadedDownloader()
  * \param[in] _url The URL for the Downloader.
  * \param[in] _cached Whether or not to cache this download.
  */
-CurlDownloader::CurlDownloader(const tiny_string& _url, bool _cached, ILoadable* o):
-	ThreadedDownloader(_url, _cached, o)
+CurlDownloader::CurlDownloader(const tiny_string& _url, _R<StreamCache> _cache, ILoadable* o):
+	ThreadedDownloader(_url, _cache, o)
 {
 }
 
@@ -1057,9 +533,10 @@ CurlDownloader::CurlDownloader(const tiny_string& _url, bool _cached, ILoadable*
  * \param[in] _url The URL for the Downloader.
  * \param[in] data Additional data to send to the host
  */
-CurlDownloader::CurlDownloader(const tiny_string& _url, const std::vector<uint8_t>& _data,
+CurlDownloader::CurlDownloader(const tiny_string& _url, _R<StreamCache> _cache,
+			       const std::vector<uint8_t>& _data,
 			       const std::list<tiny_string>& _headers, ILoadable* o):
-	ThreadedDownloader(_url, _data, _headers, o)
+	ThreadedDownloader(_url, _cache, _data, _headers, o)
 {
 }
 
@@ -1180,7 +657,7 @@ void CurlDownloader::execute()
 int CurlDownloader::progress_callback(void *clientp, double dltotal, double dlnow, double ultotal, double ulnow)
 {
 	CurlDownloader* th=static_cast<CurlDownloader*>(clientp);
-	return th->threadAborting || th->failed;
+	return th->threadAborting || th->cache->hasFailed();
 }
 
 /**
@@ -1224,7 +701,8 @@ size_t CurlDownloader::write_header(void *buffer, size_t size, size_t nmemb, voi
  * \param[in] _url The URL for the Downloader.
  * \param[in] _cached Whether or not to cache this download.
  */
-LocalDownloader::LocalDownloader(const tiny_string& _url, bool _cached, ILoadable* o):ThreadedDownloader(_url, _cached, o)
+LocalDownloader::LocalDownloader(const tiny_string& _url, _R<StreamCache> _cache, ILoadable* o):
+	ThreadedDownloader(_url, _cache, o)
 {
 }
 
@@ -1256,18 +734,14 @@ void LocalDownloader::execute()
 		LOG(LOG_INFO, _("NET: LocalDownloader::execute: reading local file: ") << url.raw_buf());
 		//If the caching is selected, we override the normal behaviour and use the local file as the cache file
 		//This prevents unneeded copying of the file's data
-		if(isCached())
-		{
-			Mutex::Lock l(mutex);
-			//Make sure we don't delete the local file afterwards
-			keepCache = true;
 
-			openExistingCache(url);
+		FileStreamCache *fileCache = dynamic_cast<FileStreamCache *>(cache.getPtr());
+		if (fileCache)
+		{
+			fileCache->useExistingFile(url);
 
-			cache.seekg(0, std::ios::end);
 			//Report that we've downloaded everything already
-			length = cache.tellg();
-			receivedLength = length;
+			length = fileCache->getReceivedLength();
 			notifyOwnerAboutBytesLoaded();
 			notifyOwnerAboutBytesTotal();
 		}
@@ -1280,7 +754,6 @@ void LocalDownloader::execute()
 			{
 				file.seekg(0, std::ios::end);
 				{
-					Mutex::Lock l(mutex);
 					setLength(file.tellg());
 				}
 				file.seekg(0, std::ios::beg);
@@ -1290,7 +763,7 @@ void LocalDownloader::execute()
 				bool readFailed = 0;
 				while(!file.eof())
 				{
-					if(file.fail() || hasFailed())
+					if(file.fail() || cache->hasFailed())
 					{
 						readFailed = 1;
 						break;
@@ -1329,7 +802,7 @@ DownloaderThreadBase::DownloaderThreadBase(_NR<URLRequest> request, IDownloaderT
 	}
 }
 
-bool DownloaderThreadBase::createDownloader(bool cached,
+bool DownloaderThreadBase::createDownloader(_R<StreamCache> cache,
 					    _NR<EventDispatcher> dispatcher,
 					    ILoadable* owner,
 					    bool checkPolicyFile)
@@ -1355,11 +828,11 @@ bool DownloaderThreadBase::createDownloader(bool cached,
 	if(postData.empty())
 	{
 		//This is a GET request
-		downloader=getSys()->downloadManager->download(url, cached, owner);
+		downloader=getSys()->downloadManager->download(url, cache, owner);
 	}
 	else
 	{
-		downloader=getSys()->downloadManager->downloadWithData(url, postData, requestHeaders, owner);
+		downloader=getSys()->downloadManager->downloadWithData(url, cache, postData, requestHeaders, owner);
 	}
 
 	return true;
diff --git a/src/backends/netutils.h b/src/backends/netutils.h
index de2789b..3220ac6 100644
--- a/src/backends/netutils.h
+++ b/src/backends/netutils.h
@@ -29,6 +29,7 @@
 #include "swftypes.h"
 #include "thread_pool.h"
 #include "backends/urlutils.h"
+#include "backends/streamcache.h"
 #include "smartrefs.h"
 
 namespace lightspark
@@ -57,8 +58,9 @@ protected:
 	void cleanUp();
 public:
 	virtual ~DownloadManager();
-	virtual Downloader* download(const URLInfo& url, bool cached, ILoadable* owner)=0;
-	virtual Downloader* downloadWithData(const URLInfo& url, const std::vector<uint8_t>& data,
+	virtual Downloader* download(const URLInfo& url, _R<StreamCache> cache, ILoadable* owner)=0;
+	virtual Downloader* downloadWithData(const URLInfo& url, _R<StreamCache> cache, 
+			const std::vector<uint8_t>& data,
 			const std::list<tiny_string>& headers, ILoadable* owner)=0;
 	virtual void destroy(Downloader* downloader)=0;
 	void stopAll();
@@ -72,57 +74,22 @@ class DLL_PUBLIC StandaloneDownloadManager:public DownloadManager
 public:
 	StandaloneDownloadManager();
 	~StandaloneDownloadManager();
-	Downloader* download(const URLInfo& url, bool cached, ILoadable* owner);
-	Downloader* downloadWithData(const URLInfo& url, const std::vector<uint8_t>& data,
+	Downloader* download(const URLInfo& url, _R<StreamCache> cache, ILoadable* owner);
+	Downloader* downloadWithData(const URLInfo& url, _R<StreamCache> cache,
+			const std::vector<uint8_t>& data,
 			const std::list<tiny_string>& headers, ILoadable* owner);
 	void destroy(Downloader* downloader);
 };
 
-class DLL_PUBLIC Downloader: public std::streambuf
+class DLL_PUBLIC Downloader
 {
-private:
-	//Handles streambuf out-of-data events
-	virtual int_type underflow();
-	//Seeks to absolute position
-	virtual pos_type seekoff(off_type, std::ios_base::seekdir, std::ios_base::openmode);
-	//Seeks to relative position
-	virtual pos_type seekpos(pos_type, std::ios_base::openmode);
-	//Helper to get the current offset
-	pos_type getOffset() const;
 protected:
 	//Abstract base class, can't be constructed
-	Downloader(const tiny_string& _url, bool _cached, ILoadable* o);
-	Downloader(const tiny_string& _url, const std::vector<uint8_t>& data,
+	Downloader(const tiny_string& _url, _R<StreamCache> _cache, ILoadable* o);
+	Downloader(const tiny_string& _url, _R<StreamCache> _cache, const std::vector<uint8_t>& data,
 		   const std::list<tiny_string>& headers, ILoadable* o);
-	//-- LOCKING
-	//Provides internal mutual exclusing
-	Mutex mutex;
-	//Signals the cache opening
-	Semaphore cacheOpened;
-	//Signals new bytes available for reading
-	Semaphore dataAvailable;
-	//Signals termination of the download
-	Semaphore terminated;
-	//True if the download is terminated
-	bool hasTerminated;
-	//True if cache has opened
-	bool cacheHasOpened;
-
-	//-- STATUS
-	//True if the downloader is waiting for the cache to be opened
-	bool waitingForCache;
-	//True if the downloader is waiting for data
-	bool waitingForData;
-	void waitForData_locked();
-	//True if the downloader is waiting for termination
-	bool waitingForTermination;
 
 	//-- FLAGS
-	//This flag forces a stop in internal code
-	bool forceStop;
-	//These flags specify what type of termination happened
-	bool failed;
-	bool finished;
 	//Mark the download as failed
 	void setFailed();
 	//Mark the download as finished
@@ -132,43 +99,14 @@ protected:
 	tiny_string url;
 	tiny_string originalURL;
 
-	//-- BUFFERING
-	//This will hold the whole download (non-cached) or a window into the download (cached)
-	uint8_t* buffer;
-	//We can't change the used buffer (for example when resizing) asynchronously. We can only do that on underflows
-	uint8_t* stableBuffer;
-	//Minimum growth of the buffer
-	static const size_t bufferMinGrowth = 4096;
-	//(Re)allocate the buffer
-	void allocateBuffer(size_t size);
-	//Synchronize stableBuffer and buffer
-	void syncBuffers();
+	//-- CACHING
+        _R<StreamCache> cache;
 
 	//-- PROGRESS MONITORING
 	ILoadable* owner;
 	void notifyOwnerAboutBytesTotal() const;
 	void notifyOwnerAboutBytesLoaded() const;
 
-	//-- CACHING
-	//Cache filename
-	tiny_string cacheFilename;
-	//Cache fstream
-	std::fstream cache;
-	//Position of the cache buffer into the file
-	uint32_t cachePos;
-	//Size of data in the buffer
-	uint32_t cacheSize;
-	//Maximum size of the cache buffer
-	static const size_t cacheMaxSize = 8192;
-	//True if the cache file doesn't need to be deleted on destruction
-	bool keepCache:1;
-	//True if the file is cached to disk (default = false)
-	bool cached:1;
-	//Creates & opens a temporary cache file
-	void openCache();
-	//Opens an existing cache file
-	void openExistingCache(tiny_string filename);
-
 	//-- HTTP REDIRECTION, STATUS & HEADERS
 	bool redirected:1;
 	void setRedirected(const tiny_string& newURL)
@@ -187,8 +125,6 @@ protected:
 	//-- DOWNLOADED DATA
 	//File length (can change in certain cases, resulting in reallocation of the buffer (non-cached))
 	uint32_t length;
-	//Amount of data already received
-	uint32_t receivedLength;
 	//Append data to the internal buffer
 	void append(uint8_t* buffer, uint32_t length);
 	//Set the length of the downloaded file, can be called multiple times to accomodate a growing file
@@ -198,28 +134,23 @@ public:
 	virtual ~Downloader();
 	//Stop the download
 	void stop();
-	//Wait for cache to be opened
-	void waitForCache();
-	//Wait for data to become available
-	void waitForData() { Mutex::Lock l(mutex); waitForData_locked(); }
-	//Wait for the download to terminate
-	void waitForTermination();
 
 	//True if the download has failed
-	bool hasFailed() { return failed; }
+	bool hasFailed() { return cache->hasFailed(); }
 	//True if the download has finished
 	//Can be used in conjunction with failed to find out if it finished successfully
-	bool hasFinished() { return finished; }
-
-	//True if the download is cached
-	bool isCached() { return cached; }
+	bool hasFinished() { return cache->hasTerminated(); }
 
 	const tiny_string& getURL() { return url; }
 
+	//Wait until the downloader completes
+	void waitForTermination() { return cache->waitForTermination(); }
+
+	_R<StreamCache> getCache() { return cache; }
 	//Gets the total length of the downloaded file (may change)
 	uint32_t getLength() { return length; }
 	//Gets the length of downloaded data
-	uint32_t getReceivedLength() { return receivedLength; }
+	uint32_t getReceivedLength() { return cache->getReceivedLength(); }
 
 	size_t getHeaderCount() { return headers.size(); }
 	tiny_string getHeader(const char* header) { return getHeader(tiny_string(header)); }
@@ -245,8 +176,9 @@ public:
 	void waitFencing();
 protected:
 	//Abstract base class, can not be constructed
-	ThreadedDownloader(const tiny_string& url, bool cached, ILoadable* o);
-	ThreadedDownloader(const tiny_string& url, const std::vector<uint8_t>& data,
+	ThreadedDownloader(const tiny_string& url, _R<StreamCache> cache, ILoadable* o);
+	ThreadedDownloader(const tiny_string& url, _R<StreamCache> cache,
+			   const std::vector<uint8_t>& data,
 			   const std::list<tiny_string>& headers, ILoadable* o);
 //	//This class can only get destroyed by DownloadManager
 //	virtual ~ThreadedDownloader();
@@ -262,8 +194,8 @@ private:
 	void execute();
 	void threadAbort();
 public:
-	CurlDownloader(const tiny_string& _url, bool _cached, ILoadable* o);
-	CurlDownloader(const tiny_string& _url, const std::vector<uint8_t>& data,
+	CurlDownloader(const tiny_string& _url, _R<StreamCache> cache, ILoadable* o);
+	CurlDownloader(const tiny_string& _url, _R<StreamCache> cache, const std::vector<uint8_t>& data,
 		       const std::list<tiny_string>& headers, ILoadable* o);
 };
 
@@ -280,7 +212,7 @@ private:
 	//Size of the reading buffer
 	static const size_t bufSize = 8192;
 public:
-	LocalDownloader(const tiny_string& _url, bool _cached, ILoadable* o);
+	LocalDownloader(const tiny_string& _url, _R<StreamCache> _cache, ILoadable* o);
 };
 
 class IDownloaderThreadListener
@@ -306,7 +238,7 @@ protected:
 	std::list<tiny_string> requestHeaders;
 	Spinlock downloaderLock;
 	Downloader* downloader;
-	bool createDownloader(bool cached,
+	bool createDownloader(_R<StreamCache> cache,
 			      _NR<EventDispatcher> dispatcher=NullRef,
 			      ILoadable* owner=NULL,
 			      bool checkPolicyFile=true);
diff --git a/src/backends/rtmputils.cpp b/src/backends/rtmputils.cpp
index 131ae48..3b6865b 100644
--- a/src/backends/rtmputils.cpp
+++ b/src/backends/rtmputils.cpp
@@ -20,6 +20,7 @@
 #include "backends/rtmputils.h"
 #include "logger.h"
 #include "swf.h"
+#include "backends/streamcache.h"
 
 #ifdef ENABLE_RTMP
 #include <librtmp/rtmp.h>
@@ -28,8 +29,9 @@
 using namespace lightspark;
 using namespace std;
 
-RTMPDownloader::RTMPDownloader(const tiny_string& _url, const tiny_string& _stream, ILoadable* o):
-	ThreadedDownloader(_url, true, o),
+RTMPDownloader::RTMPDownloader(const tiny_string& _url, _R<StreamCache> _cache,
+			       const tiny_string& _stream, ILoadable* o):
+	ThreadedDownloader(_url, _cache, o),
 	stream(_stream)
 {
 }
diff --git a/src/backends/rtmputils.h b/src/backends/rtmputils.h
index 7e9de51..6082152 100644
--- a/src/backends/rtmputils.h
+++ b/src/backends/rtmputils.h
@@ -34,7 +34,8 @@ private:
 	void threadAbort();
 	tiny_string stream;
 public:
-	RTMPDownloader(const tiny_string& _url, const tiny_string& _stream, ILoadable* o);
+	RTMPDownloader(const tiny_string& _url, _R<StreamCache> _cache,
+		       const tiny_string& _stream, ILoadable* o);
 };
 
 };
diff --git a/src/backends/security.cpp b/src/backends/security.cpp
index f460560..4711459 100644
--- a/src/backends/security.cpp
+++ b/src/backends/security.cpp
@@ -1001,7 +1001,7 @@ bool URLPolicyFile::retrievePolicyFile(vector<unsigned char>& outData)
 	bool ok = true;
 
 	//No caching needed for this download, we don't expect very big files
-	Downloader* downloader=getSys()->downloadManager->download(url, false, NULL);
+	Downloader* downloader=getSys()->downloadManager->download(url, _MR(new MemoryStreamCache), NULL);
 
 	//Wait until the file is fetched
 	downloader->waitForTermination();
@@ -1052,11 +1052,13 @@ bool URLPolicyFile::retrievePolicyFile(vector<unsigned char>& outData)
 
 	if (ok)
 	{
-		istream s(downloader);
+		std::streambuf *sbuf = downloader->getCache()->createReader();
+		istream s(sbuf);
 		size_t bufLength = downloader->getLength();
 		size_t offset = outData.size();
 		outData.resize(offset+bufLength);
 		s.read((char*)&outData[offset], bufLength);
+		delete sbuf;
 	}
 
 	getSys()->downloadManager->destroy(downloader);
diff --git a/src/backends/streamcache.cpp b/src/backends/streamcache.cpp
new file mode 100644
index 0000000..a6ed091
--- /dev/null
+++ b/src/backends/streamcache.cpp
@@ -0,0 +1,494 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include <string.h>
+#include <unistd.h>
+#include <glib.h>
+#include "backends/streamcache.h"
+#include "backends/config.h"
+#include "exceptions.h"
+#include "logger.h"
+
+using namespace std;
+using namespace lightspark;
+
+StreamCache::StreamCache()
+  : receivedLength(0), failed(false), terminated(false)
+{
+}
+
+void StreamCache::markFinished(bool _failed)
+{
+	Locker locker(stateMutex);
+	if (terminated)
+		return;
+
+	failed = _failed;
+	terminated = true;
+	stateCond.broadcast();
+}
+
+void StreamCache::waitForData(size_t currentOffset)
+{
+	Locker locker(stateMutex);
+	while (receivedLength <= currentOffset && !terminated)
+		stateCond.wait(stateMutex);
+}
+
+void StreamCache::waitForTermination()
+{
+	Locker locker(stateMutex);
+	while (!terminated)
+		stateCond.wait(stateMutex);
+}
+
+void StreamCache::append(const unsigned char* buffer, size_t length)
+{
+	if (!buffer || length == 0 || terminated)
+		return;
+
+	handleAppend(buffer, length);
+
+	{
+		Locker locker(stateMutex);
+		receivedLength += length;
+		stateCond.broadcast();
+	}
+}
+
+class lightspark::MemoryChunk {
+public:
+	MemoryChunk(size_t len);
+	~MemoryChunk();
+	unsigned char * const buffer;
+	const size_t capacity;
+	ACQUIRE_RELEASE_VARIABLE(size_t, used);
+};
+
+MemoryChunk::MemoryChunk(size_t len) :
+	buffer(new unsigned char[len]), capacity(len), used(0)
+{
+}
+
+MemoryChunk::~MemoryChunk()
+{
+	delete[] buffer;
+}
+
+MemoryStreamCache::MemoryStreamCache():
+	writeChunk(NULL), nextChunkSize(0)
+{
+}
+
+MemoryStreamCache::~MemoryStreamCache()
+{
+	for (auto it=chunks.begin(); it!=chunks.end(); ++it)
+		delete *it;
+}
+
+// Rounds val up to the next multiple of pow(2, s).
+static size_t nextMultipleOf2Pow(size_t val, size_t s)
+{
+	return ((size_t)((double)(val-1) / (1 << s)) + 1) << s;
+}
+
+void MemoryStreamCache::allocateChunk(size_t minLength)
+{
+	size_t len = imax(imax(minLength, minChunkSize), nextChunkSize);
+	len = nextMultipleOf2Pow(len, 12);
+	assert(len >= minLength);
+	nextChunkSize = len;
+
+	{
+		Locker locker(chunkListMutex);
+		writeChunk = new MemoryChunk(len);
+		chunks.push_back(writeChunk);
+	}
+}
+
+void MemoryStreamCache::handleAppend(const unsigned char* data, size_t length)
+{
+	assert(length > 0);
+
+	if (!writeChunk || (ACQUIRE_READ(writeChunk->used) >= writeChunk->capacity))
+		allocateChunk(length);
+
+	assert(writeChunk);
+
+	size_t used = ACQUIRE_READ(writeChunk->used);
+	if (writeChunk->capacity >= used + length)
+	{
+		// Data fits in to the current chunk
+		memcpy(writeChunk->buffer + used, data, length);
+		RELEASE_WRITE(writeChunk->used, used + length);
+	}
+	else
+	{
+		// Write as much as possible to the current buffer
+		size_t unused = writeChunk->capacity - used;
+		memcpy(writeChunk->buffer + used, data, unused);
+		RELEASE_WRITE(writeChunk->used, writeChunk->capacity);
+
+		// allocate a new chunk by a recursive call
+		handleAppend(data + unused, length - unused);
+	}
+}
+
+void MemoryStreamCache::reserve(size_t expectedLength)
+{
+	if (expectedLength <= receivedLength)
+		return;
+
+	// Set the next chunk to be large enough to hold the remaining
+	// of the stream. The memory will be actually allocated in
+	// append().
+	size_t unused = 0;
+	if (writeChunk)
+		unused = writeChunk->capacity - ACQUIRE_READ(writeChunk->used);
+
+	size_t allocated = receivedLength + unused;
+	if (expectedLength > allocated)
+		nextChunkSize = expectedLength - allocated;
+}
+
+std::streambuf *MemoryStreamCache::createReader()
+{
+	incRef();
+	return new MemoryStreamCache::Reader(_MR(this));
+}
+
+MemoryStreamCache::Reader::Reader(_R<MemoryStreamCache> b) :
+	buffer(b), chunkIndex(0), chunkStartOffset(0)
+{
+	setg(NULL, NULL, NULL);
+}
+
+/**
+ * \brief Called by the streambuf API
+ *
+ * Called by the streambuf API when there is no more data to read.
+ */
+int MemoryStreamCache::Reader::underflow()
+{
+	Locker locker(buffer->chunkListMutex);
+
+	// Wait until there is some data to be read or until terminated
+	bool hasMoreChunks = chunkIndex+1 < buffer->chunks.size();
+	bool lastChunkHasBytes = (chunkIndex+1 == buffer->chunks.size()) && 
+		((size_t)(gptr() - eback()) < ACQUIRE_READ(buffer->chunks[chunkIndex]->used));
+	if (!buffer->hasTerminated() && !hasMoreChunks && !lastChunkHasBytes)
+	{
+		locker.release();
+		buffer->waitForData(getOffset());
+		locker.acquire();
+	}
+
+	if (chunkIndex >= buffer->chunks.size())
+	{
+		// This can only happen if the stream is terminated
+		// before any data is written.
+		assert(chunkIndex == 0);
+		assert(buffer->hasTerminated());
+		return EOF;
+	}
+
+	MemoryChunk *chunk = buffer->chunks[chunkIndex];
+	size_t used = ACQUIRE_READ(chunk->used);
+	unsigned char *cursor;
+	unsigned char *end = chunk->buffer + used;
+
+	if (gptr() == NULL)
+	{
+		// On the first call gptr() is NULL (as set in the
+		// constructor). Nothing has been read yet.
+		cursor = chunk->buffer;
+	}
+	else if ((unsigned char*)gptr() < end)
+	{
+		// Data left in this chunk
+		cursor = (unsigned char*)gptr();
+	}
+	else if (chunkIndex == buffer->chunks.size()-1)
+	{
+		// This is the last received chunk and there is no
+		// data to be read => we're finished
+		assert(buffer->hasTerminated());
+		return EOF;
+	}
+	else
+	{
+		// Move to the next chunk
+		chunkStartOffset = chunkStartOffset + used;
+		chunkIndex++;
+
+		// chunkIndex is still valid, because the case
+		// size()-1 was handled above
+		assert_and_throw(chunkIndex < buffer->chunks.size());
+
+		chunk = buffer->chunks[chunkIndex];
+		cursor = chunk->buffer;
+		end = chunk->buffer + ACQUIRE_READ(chunk->used);
+	}
+
+	setg((char *)chunk->buffer, (char *)cursor, (char *)end);
+
+	assert(cursor != end); // there is at least one byte to return
+	return (int)cursor[0];
+}
+
+/**
+ * \brief Called by the streambuf API
+ *
+ * Called by the streambuf API to seek to a relative position
+ */
+streampos MemoryStreamCache::Reader::seekoff(streamoff off, std::ios_base::seekdir dir,
+					     std::ios_base::openmode mode)
+{
+	if (mode != std::ios_base::in)
+		return -1;
+
+	switch (dir)
+	{
+		case std::ios_base::beg:
+			seekpos(off, mode);
+			break;
+		case std::ios_base::cur:
+			// TODO: optimize by checking if the new
+			// offset is in the current chunk
+			seekpos(getOffset() + off, mode);
+			break;
+		case std::ios_base::end:
+			buffer->waitForTermination();
+			if (buffer->hasFailed())
+				return -1;
+
+			seekpos((streampos)buffer->getReceivedLength() + off, mode);
+			break;
+		default:
+			break;
+	}
+
+	return getOffset();
+}
+
+/**
+ * \brief Called by the streambuf API
+ *
+ * Called by the streambuf API to seek to an absolute position
+ */
+streampos MemoryStreamCache::Reader::seekpos(streampos pos, std::ios_base::openmode mode)
+{
+	if (mode != std::ios_base::in || pos < 0)
+		return -1;
+
+	if (pos >= (streampos)buffer->getReceivedLength())
+		buffer->waitForTermination();
+
+	Locker locker(buffer->chunkListMutex);
+	streampos offset = 0;
+	for (auto it=buffer->chunks.begin(); it!=buffer->chunks.end(); ++it)
+	{
+		streampos used = (streampos)ACQUIRE_READ((*it)->used);
+		if (pos >= offset + used)
+		{
+			offset += used;
+		}
+		else
+		{
+			setg((char *)(*it)->buffer,
+			     (char *)((*it)->buffer + (pos - offset)),
+			     (char *)((*it)->buffer + used));
+			return pos;
+		}
+	}
+
+	return -1;
+}
+
+/**
+ * Get the position of the read cursor in the (virtual) downloaded data.
+ */
+streampos MemoryStreamCache::Reader::getOffset() const
+{
+	return chunkStartOffset + (size_t)(gptr() - eback());
+}
+
+FileStreamCache::FileStreamCache()
+  : keepCache(false)
+{
+}
+
+FileStreamCache::~FileStreamCache()
+{
+	if (cache.is_open())
+		cache.close();
+	if (!keepCache && !cacheFilename.empty())
+		unlink(cacheFilename.raw_buf());
+}
+
+void FileStreamCache::handleAppend(const unsigned char* buffer, size_t length)
+{
+	if (!cache.is_open())
+		openCache();
+
+	cache.write((const char*)buffer, length);
+	cache.sync();
+}
+
+/**
+ * \brief Creates & opens a temporary cache file
+ *
+ * Creates a temporary cache file in /tmp and calls \c openExistingCache() with that file.
+ * Waits for mutex at start and releases mutex when finished.
+ * \throw RunTimeException Temporary file could not be created
+ * \throw RunTimeException Called when  the cache is already open
+ * \see Downloader::openExistingCache()
+ */
+void FileStreamCache::openCache()
+{
+	if (cache.is_open())
+	{
+		markFinished(true);
+		throw RunTimeException(_("FileStreamCache::openCache called twice"));
+	}
+
+	//Create a temporary file(name)
+	std::string cacheFilenameS = Config::getConfig()->getCacheDirectory() + "/" + Config::getConfig()->getCachePrefix() + "XXXXXX";
+	char* cacheFilenameC = g_newa(char,cacheFilenameS.length()+1);
+	strncpy(cacheFilenameC, cacheFilenameS.c_str(), cacheFilenameS.length());
+	cacheFilenameC[cacheFilenameS.length()] = '\0';
+	int fd = g_mkstemp(cacheFilenameC);
+	if(fd == -1)
+	{
+		markFinished(true);
+		throw RunTimeException(_("FileStreamCache::openCache: cannot create temporary file"));
+	}
+
+	//We are using fstream to read/write to the cache, so we don't need this FD
+	close(fd);
+
+	//Let the openExistingCache function handle the rest
+	openExistingCache(tiny_string(cacheFilenameC, true));
+}
+
+/**
+ * \brief Opens an existing cache file
+ *
+ * Opens an existing cache file, allocates the buffer and signals \c cacheOpened.
+ * \post \c cacheFilename is set
+ * \post \c cache file is opened
+ * \throw RunTimeException File could not be opened
+ * \throw RunTimeException Called when the cache is already open
+ */
+void FileStreamCache::openExistingCache(const tiny_string& filename)
+{
+	if (cache.is_open())
+	{
+		markFinished(true);
+		throw RunTimeException(_("FileStreamCache::openCache called twice"));
+	}
+
+	cacheFilename = filename;
+
+	//Open the cache file
+	cache.open(cacheFilename.raw_buf(), std::fstream::binary | std::fstream::out);
+	if (!cache.is_open())
+	{
+		markFinished(true);
+		throw RunTimeException(_("FileStreamCache::openCache: cannot open temporary cache file"));
+	}
+
+	LOG(LOG_INFO, _("NET: Downloading to cache file: ") << cacheFilename);
+}
+
+void FileStreamCache::useExistingFile(const tiny_string& filename)
+{
+	//Make sure we don't delete the local file afterwards
+	keepCache = true;
+
+	cacheFilename = filename;
+	openExistingCache(filename);
+
+	cache.seekg(0, std::ios::end);
+	receivedLength = cache.tellg();
+
+	// We already have the whole file
+	markFinished();
+}
+
+void FileStreamCache::waitForCache()
+{
+	if (cache.is_open())
+		return;
+
+	// Cache file will be opened when the first byte is received
+	waitForData(0);
+
+	// Check if the stream was terminated before anything was written
+	if (!cache.is_open())
+		throw RunTimeException(_("FileStreamCache::waitForCache: cache file is not open"));
+}
+
+std::streambuf *FileStreamCache::createReader()
+{
+	waitForCache();
+
+	incRef();
+	FileStreamCache::Reader *fbuf = new FileStreamCache::Reader(_MR(this));
+	fbuf->open(cacheFilename.raw_buf(), std::fstream::binary | std::fstream::in);
+	if (!fbuf->is_open())
+	{
+		delete fbuf;
+		throw RunTimeException(_("FileStreamCache::createReader: opening cache file for reading failed"));
+	}
+	return fbuf;
+}
+
+FileStreamCache::Reader::Reader(_R<FileStreamCache> b) : buffer(b)
+{
+}
+
+int FileStreamCache::Reader::underflow()
+{
+	if (!buffer->hasTerminated())
+		buffer->waitForData(seekoff(0, ios_base::cur, ios_base::in));
+
+	return filebuf::underflow();
+}
+
+streamsize FileStreamCache::Reader::xsgetn(char* s, streamsize n)
+{
+	streamsize read=filebuf::xsgetn(s, n);
+
+	// If not enough data was available, wait for writer
+	while (read < n)
+	{
+		buffer->waitForData(seekoff(0, ios_base::cur, ios_base::in));
+
+		streamsize b = filebuf::xsgetn(s+read, n-read);
+
+		// No more data after waiting, this must be EOF
+		if (b == 0)
+			return read;
+
+		read += b;
+	}
+
+	return read;
+}
diff --git a/src/backends/streamcache.h b/src/backends/streamcache.h
new file mode 100644
index 0000000..7b03bb0
--- /dev/null
+++ b/src/backends/streamcache.h
@@ -0,0 +1,197 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef BACKENDS_STREAMCACHE_H
+#define BACKENDS_STREAMCACHE_H 1
+
+#include <list>
+#include <istream>
+#include <fstream>
+#include <cstdint>
+#include "threading.h"
+#include "tiny_string.h"
+#include "smartrefs.h"
+#include "compat.h"
+
+namespace lightspark
+{
+
+/*
+ * A single-writer-multiple-reader buffer for downloaded streams.
+ *
+ * Writing is done by one thread by calling append(), reading is done
+ * through streambuf interface (constructred by createReader()) in a
+ * separate thread. There can be several readers in multiple threads.
+ *
+ * This is an abstract base class.
+ */
+class DLL_PUBLIC StreamCache : public RefCountable {
+protected:
+	StreamCache() DLL_LOCAL;
+
+	// stateMutex must be held while receivedLength, failed or
+	// terminated are accessed
+	Mutex stateMutex;
+	// stateCond is signalled when data is received or the stream
+	// is terminated
+	Cond stateCond;
+	// Amount of data already received
+	size_t receivedLength;
+	// Has the stream been completely downloaded or failed?
+	bool failed:1;
+	bool terminated:1;
+
+	// Wait until more than currentOffset bytes has been received
+	// or until terminated
+	void waitForData(size_t currentOffset) DLL_LOCAL;
+
+	// Derived class implements this to store received data
+	virtual void handleAppend(const unsigned char* buffer, size_t length)=0;
+
+public:
+	virtual ~StreamCache() {}
+
+	// Gets the length of downloaded data
+	size_t getReceivedLength() const { return receivedLength; }
+
+	bool hasTerminated() const { return terminated; }
+	bool hasFailed() const { return failed; }
+
+	// Wait until the writer calls markTerminated
+	void waitForTermination();
+
+	// Set the expected length of the stream.
+	// The default implementation does nothing, but the derived
+	// classes can allocate memory here.
+	virtual void reserve(size_t expectedLength) {}
+
+	// Write new data to the buffer (writer thread)
+	void append(const unsigned char* buffer, size_t length);
+
+	// Writer should call this when all of the stream has been
+	// append()'ed
+	void markFinished(bool failed=false);
+
+	// Create a streambuf for reading from this buffer (reader
+	// thread). Every call returns a new, independent streambuf.
+	// The caller must delete the returned value.
+	virtual std::streambuf *createReader()=0;
+};
+
+class MemoryChunk;
+
+/*
+ * MemoryStreamCache buffers the stream in memory.
+ */
+class DLL_PUBLIC MemoryStreamCache : public StreamCache {
+private:
+	class DLL_LOCAL Reader : public std::streambuf {
+	private:
+		_R<MemoryStreamCache> buffer;
+		// The chunk that is currently being read
+		unsigned int chunkIndex;
+		// Offset at the start of current chunk
+		size_t chunkStartOffset;
+
+		// Handles streambuf out-of-data events
+		virtual int underflow();
+		// Seeks to absolute position
+		virtual std::streampos seekoff(std::streamoff, std::ios_base::seekdir, std::ios_base::openmode);
+		// Seeks to relative position
+		virtual std::streampos seekpos(std::streampos, std::ios_base::openmode);
+		// Helper to get the current offset
+		std::streampos getOffset() const;
+	public:
+		Reader(_R<MemoryStreamCache> b);
+	};
+
+	// Stream is stored into a sequence of memory chunks. The
+	// chunks can grow, but they are never moved, so both readers
+	// and writer can safely use them. However, the mutex must be
+	// held when the container is accessed.
+	Mutex chunkListMutex;
+	std::vector<MemoryChunk *> chunks;
+
+	// The last chunk, the next write will happen here (writer thread)
+	MemoryChunk *writeChunk;
+
+	// Variables controlling the memory allocation
+	size_t nextChunkSize;
+	static const size_t minChunkSize = 4*4096;
+
+	// Allocate a new chunk, append it to chunks, update writeChunk
+	void allocateChunk(size_t minLength) DLL_LOCAL;
+
+	virtual void handleAppend(const unsigned char* buffer, size_t length) DLL_LOCAL;
+
+public:
+	MemoryStreamCache();
+	virtual ~MemoryStreamCache();
+
+	virtual void reserve(size_t expectedLength);
+
+	virtual std::streambuf *createReader();
+};
+
+/*
+ * FileStreamCache saves the stream in a temporary file.
+ */
+class DLL_PUBLIC FileStreamCache : public StreamCache {
+private:
+	/*
+	 * Extends filebuf to wait for writer thread to supply more
+	 * data when the end of temporary file is reached.
+	 */
+	class DLL_LOCAL Reader : public std::filebuf {
+	private:
+		_R<FileStreamCache> buffer;
+		virtual int underflow();
+		virtual std::streamsize xsgetn(char* s, std::streamsize n);
+	public:
+		Reader(_R<FileStreamCache> buffer);
+	};
+
+	//Cache filename
+	tiny_string cacheFilename;
+	//Cache fstream
+	std::fstream cache;
+	//True if the cache file doesn't need to be deleted on destruction
+	bool keepCache:1;
+
+	void openCache() DLL_LOCAL;
+	void openExistingCache(const tiny_string& filename) DLL_LOCAL;
+
+	// Block until the cache file is opened by the writer stream
+	void waitForCache() DLL_LOCAL;
+
+	virtual void handleAppend(const unsigned char* buffer, size_t length) DLL_LOCAL;
+
+public:
+	FileStreamCache();
+	virtual ~FileStreamCache();
+
+	virtual std::streambuf *createReader();
+
+	// Use an existing file as cache. Must be called before append().
+	void useExistingFile(const tiny_string& filename);
+};
+
+};
+
+#endif // BACKENDS_STREAMCACHE_H
diff --git a/src/compat.h b/src/compat.h
index 5934b65..0cc00c3 100644
--- a/src/compat.h
+++ b/src/compat.h
@@ -116,6 +116,7 @@ _CRTIMP char* __cdecl __MINGW_NOTHROW   _strdup (const char*) __MINGW_ATTRIB_MAL
 
 //Boolean type with acquire release barrier semantics
 #define ACQUIRE_RELEASE_FLAG(x) std::atomic_bool x
+#define ACQUIRE_RELEASE_VARIABLE(t, x) std::atomic<t> x
 #define ACQUIRE_READ(x) x.load(std::memory_order_acquire)
 #define RELEASE_WRITE(x, v) x.store(v, std::memory_order_release)
 
diff --git a/src/plugin/plugin.cpp b/src/plugin/plugin.cpp
index e8338e0..1ff0ba2 100644
--- a/src/plugin/plugin.cpp
+++ b/src/plugin/plugin.cpp
@@ -20,6 +20,7 @@
 
 #include "version.h"
 #include "backends/security.h"
+#include "backends/streamcache.h"
 #include "plugin/plugin.h"
 #include "logger.h"
 #include "compat.h"
@@ -63,18 +64,22 @@ NPDownloadManager::NPDownloadManager(NPP _instance):instance(_instance)
  * \return A pointer to a newly created \c Downloader for the given URL.
  * \see DownloadManager::destroy()
  */
-lightspark::Downloader* NPDownloadManager::download(const lightspark::URLInfo& url, bool cached, lightspark::ILoadable* owner)
+lightspark::Downloader* NPDownloadManager::download(const lightspark::URLInfo& url, _R<StreamCache> cache, lightspark::ILoadable* owner)
 {
 	// Handle RTMP requests internally, not through NPAPI
 	if(url.isRTMP())
 	{
-		return StandaloneDownloadManager::download(url, cached, owner);
+		return StandaloneDownloadManager::download(url, cache, owner);
 	}
 
+	// FIXME: dynamic_cast fails because the linker doesn't find
+	// typeinfo for FileStreamCache
+	//bool cached = dynamic_cast<FileStreamCache *>(cache.getPtr()) != NULL;
+	bool cached = false;
 	LOG(LOG_INFO, _("NET: PLUGIN: DownloadManager::download '") << url.getParsedURL() << 
 			"'" << (cached ? _(" - cached") : ""));
 	//Register this download
-	NPDownloader* downloader=new NPDownloader(url.getParsedURL(), cached, instance, owner);
+	NPDownloader* downloader=new NPDownloader(url.getParsedURL(), cache, instance, owner);
 	addDownloader(downloader);
 	return downloader;
 }
@@ -88,18 +93,19 @@ lightspark::Downloader* NPDownloadManager::download(const lightspark::URLInfo& u
  * \return A pointer to a newly created \c Downloader for the given URL.
  * \see DownloadManager::destroy()
  */
-lightspark::Downloader* NPDownloadManager::downloadWithData(const lightspark::URLInfo& url, const std::vector<uint8_t>& data, 
+lightspark::Downloader* NPDownloadManager::downloadWithData(const lightspark::URLInfo& url,
+		_R<StreamCache> cache, const std::vector<uint8_t>& data,
 		const std::list<tiny_string>& headers, lightspark::ILoadable* owner)
 {
 	// Handle RTMP requests internally, not through NPAPI
 	if(url.isRTMP())
 	{
-		return StandaloneDownloadManager::downloadWithData(url, data, headers, owner);
+		return StandaloneDownloadManager::downloadWithData(url, cache, data, headers, owner);
 	}
 
 	LOG(LOG_INFO, _("NET: PLUGIN: DownloadManager::downloadWithData '") << url.getParsedURL());
 	//Register this download
-	NPDownloader* downloader=new NPDownloader(url.getParsedURL(), data, headers, instance, owner);
+	NPDownloader* downloader=new NPDownloader(url.getParsedURL(), cache, data, headers, instance, owner);
 	addDownloader(downloader);
 	return downloader;
 }
@@ -139,7 +145,7 @@ void NPDownloadManager::destroy(lightspark::Downloader* downloader)
  * \param[in] _url The URL for the Downloader.
  */
 NPDownloader::NPDownloader(const lightspark::tiny_string& _url, lightspark::ILoadable* owner):
-	Downloader(_url, false, owner),instance(NULL),cleanupInDestroyStream(true),state(INIT)
+	Downloader(_url, _MR(new MemoryStreamCache), owner),instance(NULL),cleanupInDestroyStream(true),state(INIT)
 {
 }
 
@@ -151,8 +157,8 @@ NPDownloader::NPDownloader(const lightspark::tiny_string& _url, lightspark::ILoa
  * \param[in] _instance The netscape plugin instance
  * \param[in] owner The \c LoaderInfo object that keeps track of this download
  */
-NPDownloader::NPDownloader(const lightspark::tiny_string& _url, bool _cached, NPP _instance, lightspark::ILoadable* owner):
-	Downloader(_url, _cached, owner),instance(_instance),cleanupInDestroyStream(false),state(INIT)
+NPDownloader::NPDownloader(const lightspark::tiny_string& _url, _R<StreamCache> _cache, NPP _instance, lightspark::ILoadable* owner):
+	Downloader(_url, _cache, owner),instance(_instance),cleanupInDestroyStream(false),state(INIT)
 {
 	NPN_PluginThreadAsyncCall(instance, dlStartCallback, this);
 }
@@ -165,9 +171,10 @@ NPDownloader::NPDownloader(const lightspark::tiny_string& _url, bool _cached, NP
  * \param[in] _instance The netscape plugin instance
  * \param[in] owner The \c LoaderInfo object that keeps track of this download
  */
-NPDownloader::NPDownloader(const lightspark::tiny_string& _url, const std::vector<uint8_t>& _data,
+NPDownloader::NPDownloader(const lightspark::tiny_string& _url, _R<StreamCache> _cache,
+		const std::vector<uint8_t>& _data,
 		const std::list<tiny_string>& headers, NPP _instance, lightspark::ILoadable* owner):
-	Downloader(_url, _data, headers, owner),instance(_instance),cleanupInDestroyStream(false),state(INIT)
+	Downloader(_url, _cache, _data, headers, owner),instance(_instance),cleanupInDestroyStream(false),state(INIT)
 {
 	NPN_PluginThreadAsyncCall(instance, dlStartCallback, this);
 }
@@ -313,7 +320,8 @@ void NS_DestroyPluginInstance(nsPluginInstanceBase * aPlugin)
 //
 nsPluginInstance::nsPluginInstance(NPP aInstance, int16_t argc, char** argn, char** argv) : 
 	nsPluginInstanceBase(), mInstance(aInstance),mInitialized(FALSE),mWindow(0),
-	mainDownloaderStream(NULL),mainDownloader(NULL),scriptObject(NULL),m_pt(NULL)
+	mainDownloaderStreambuf(NULL),mainDownloaderStream(NULL),
+	mainDownloader(NULL),scriptObject(NULL),m_pt(NULL)
 {
 	LOG(LOG_INFO, "Lightspark version " << VERSION << " Copyright 2009-2013 Alessandro Pignotti and others");
 	setTLSSys( NULL );
@@ -366,6 +374,8 @@ nsPluginInstance::~nsPluginInstance()
 	setTLSSys(m_sys);
 	if(mainDownloader)
 		mainDownloader->stop();
+	if (mainDownloaderStreambuf)
+		delete mainDownloaderStreambuf;
 
 	// Kill all stuff relating to NPScriptObject which is still running
 	static_cast<NPScriptObject*>(m_sys->extScriptObject)->destroy();
@@ -644,7 +654,8 @@ NPError nsPluginInstance::NewStream(NPMIMEType type, NPStream* stream, NPBool se
 		dl=new NPDownloader(stream->url,m_sys->mainClip->loaderInfo.getPtr());
 		dl->setLength(stream->end);
 		mainDownloader=dl;
-		mainDownloaderStream.rdbuf(mainDownloader);
+		mainDownloaderStreambuf = mainDownloader->getCache()->createReader();
+		mainDownloaderStream.rdbuf(mainDownloaderStreambuf);
 		m_pt=new lightspark::ParseThread(mainDownloaderStream,m_sys->mainClip);
 		m_sys->addJob(m_pt);
 	}
diff --git a/src/plugin/plugin.h b/src/plugin/plugin.h
index a8a5823..4e4962f 100644
--- a/src/plugin/plugin.h
+++ b/src/plugin/plugin.h
@@ -44,8 +44,11 @@ private:
 	NPP instance;
 public:
 	NPDownloadManager(NPP i);
-	lightspark::Downloader* download(const lightspark::URLInfo& url, bool cached, lightspark::ILoadable* owner);
-	lightspark::Downloader* downloadWithData(const lightspark::URLInfo& url, const std::vector<uint8_t>& data, 
+	lightspark::Downloader* download(const lightspark::URLInfo& url,
+					 _R<StreamCache> cache,
+					 lightspark::ILoadable* owner);
+	lightspark::Downloader* downloadWithData(const lightspark::URLInfo& url,
+			_R<StreamCache> cache, const std::vector<uint8_t>& data,
 			const std::list<tiny_string>& headers, lightspark::ILoadable* owner);
 	void destroy(lightspark::Downloader* downloader);
 };
@@ -63,8 +66,8 @@ public:
 	STATE state;
 	//Constructor used for the main file
 	NPDownloader(const lightspark::tiny_string& _url, lightspark::ILoadable* owner);
-	NPDownloader(const lightspark::tiny_string& _url, bool _cached, NPP _instance, lightspark::ILoadable* owner);
-	NPDownloader(const lightspark::tiny_string& _url, const std::vector<uint8_t>& _data,
+	NPDownloader(const lightspark::tiny_string& _url, _R<StreamCache> cache, NPP _instance, lightspark::ILoadable* owner);
+	NPDownloader(const lightspark::tiny_string& _url, _R<StreamCache> cache, const std::vector<uint8_t>& _data,
 			const std::list<tiny_string>& headers, NPP _instance, lightspark::ILoadable* owner);
 };
 
@@ -135,6 +138,7 @@ private:
 	GdkNativeWindow mWindow;
 	int mX, mY;
 
+	std::streambuf *mainDownloaderStreambuf;
 	std::istream mainDownloaderStream;
 	NPDownloader* mainDownloader;
 	NPScriptObjectGW* scriptObject;
diff --git a/src/scripting/flash/display/flashdisplay.cpp b/src/scripting/flash/display/flashdisplay.cpp
index 1fa9722..db77643 100644
--- a/src/scripting/flash/display/flashdisplay.cpp
+++ b/src/scripting/flash/display/flashdisplay.cpp
@@ -296,19 +296,23 @@ void LoaderThread::execute()
 	streambuf *sbuf = 0;
 	if(source==URL)
 	{
-		if(!createDownloader(false, loaderInfo, loaderInfo.getPtr(), false))
+		_R<MemoryStreamCache> cache(_MR(new MemoryStreamCache));
+		if(!createDownloader(cache, loaderInfo, loaderInfo.getPtr(), false))
 			return;
 
-		downloader->waitForData(); //Wait for some data, making sure our check for failure is working
-		if(downloader->hasFailed()) //Check to see if the download failed for some reason
+		sbuf = cache->createReader();
+		
+		// Wait for some data, making sure our check for failure is working
+		sbuf->sgetc(); // peek one byte
+		if(cache->hasFailed()) //Check to see if the download failed for some reason
 		{
 			LOG(LOG_ERROR, "Loader::execute(): Download of URL failed: " << url);
 			getVm()->addEvent(loaderInfo,_MR(Class<IOErrorEvent>::getInstanceS()));
+			delete sbuf;
 			// downloader will be deleted in jobFence
 			return;
 		}
 		getVm()->addEvent(loaderInfo,_MR(Class<Event>::getInstanceS("open")));
-		sbuf=downloader;
 	}
 	else if(source==BYTES)
 	{
@@ -324,19 +328,15 @@ void LoaderThread::execute()
 	ParseThread local_pt(s,loaderInfo->applicationDomain,loaderInfo->securityDomain,loader.getPtr(),url.getParsedURL());
 	local_pt.execute();
 
-	// Delete the bytes container (downloader or bytes_buf)
+	// Delete the bytes container (cache reader or bytes_buf)
+	delete sbuf;
+	sbuf = NULL;
 	if (source==URL) {
 		//Acquire the lock to ensure consistency in threadAbort
 		SpinlockLocker l(downloaderLock);
 		if(downloader)
 			getSys()->downloadManager->destroy(downloader);
 		downloader=NULL;
-		sbuf = NULL;
-	}
-	else if (source==BYTES)
-	{
-		delete sbuf;
-		sbuf = NULL;
 	}
 
 	bytes.reset();
diff --git a/src/scripting/flash/media/flashmedia.cpp b/src/scripting/flash/media/flashmedia.cpp
index 3caaa55..38c61e5 100644
--- a/src/scripting/flash/media/flashmedia.cpp
+++ b/src/scripting/flash/media/flashmedia.cpp
@@ -275,13 +275,13 @@ ASFUNCTIONBODY(Sound,load)
 	{
 		//This is a GET request
 		//Use disk cache our downloaded files
-		th->downloader=getSys()->downloadManager->download(th->url, true, th);
+		th->downloader=getSys()->downloadManager->download(th->url, _MR(new FileStreamCache), th);
 	}
 	else
 	{
 		list<tiny_string> headers=urlRequest->getHeaders();
-		th->downloader=getSys()->downloadManager->downloadWithData(th->url, th->postData,
-				headers, th);
+		th->downloader=getSys()->downloadManager->downloadWithData(th->url,
+				_MR(new MemoryStreamCache), th->postData, headers, th);
 		//Clean up the postData for the next load
 		th->postData.clear();
 	}
@@ -306,7 +306,7 @@ ASFUNCTIONBODY(Sound,play)
 	{
 		th->soundChannelCreated = true;
 		th->incRef();
-		return Class<SoundChannel>::getInstanceS(th->downloader, _MNR(th));
+		return Class<SoundChannel>::getInstanceS(th->downloader->getCache());
 	}
 	else
 	{
@@ -374,10 +374,10 @@ ASFUNCTIONBODY(SoundLoaderContext,_constructor)
 ASFUNCTIONBODY_GETTER_SETTER(SoundLoaderContext,bufferTime);
 ASFUNCTIONBODY_GETTER_SETTER(SoundLoaderContext,checkPolicyFile);
 
-SoundChannel::SoundChannel(Class_base* c, std::streambuf *s, _NR<Sound> _owner)
-  : EventDispatcher(c),stream(s),owner(_owner),stopped(false),audioDecoder(NULL),audioStream(NULL),position(0)
+SoundChannel::SoundChannel(Class_base* c, _NR<StreamCache> _stream)
+  : EventDispatcher(c),stream(_stream),stopped(false),audioDecoder(NULL),audioStream(NULL),position(0)
 {
-	if(s)
+	if (!stream.isNull())
 	{
 		// Start playback
 		incRef();
@@ -421,7 +421,11 @@ ASFUNCTIONBODY(SoundChannel, stop)
 
 void SoundChannel::execute()
 {
-	stream.exceptions ( istream::eofbit | istream::failbit | istream::badbit );
+	assert(!stream.isNull());
+
+	std::streambuf *sbuf = stream->createReader();
+	istream s(sbuf);
+	s.exceptions ( istream::eofbit | istream::failbit | istream::badbit );
 
 	bool waitForFlush=true;
 	StreamDecoder* streamDecoder=NULL;
@@ -429,7 +433,7 @@ void SoundChannel::execute()
 	try
 	{
 #ifdef ENABLE_LIBAVCODEC
-		streamDecoder=new FFMpegStreamDecoder(stream);
+		streamDecoder=new FFMpegStreamDecoder(s);
 		if(!streamDecoder->isValid())
 			threadAbort();
 
@@ -486,6 +490,7 @@ void SoundChannel::execute()
 		audioStream=NULL;
 	}
 	delete streamDecoder;
+	delete sbuf;
 
 	if (!ACQUIRE_READ(stopped))
 	{
diff --git a/src/scripting/flash/media/flashmedia.h b/src/scripting/flash/media/flashmedia.h
index b7a2841..e8a5dcd 100644
--- a/src/scripting/flash/media/flashmedia.h
+++ b/src/scripting/flash/media/flashmedia.h
@@ -72,17 +72,14 @@ public:
 class SoundChannel : public EventDispatcher, public IThreadJob
 {
 private:
-	std::istream stream;
-	// owner keeps reference to the Sound object that owns the
-	// streambuf. TODO: ugly, get rid of this
-	_NR<Sound> owner;
+        _NR<StreamCache> stream;
 	Mutex mutex;
 	ACQUIRE_RELEASE_FLAG(stopped);
 	AudioDecoder* audioDecoder;
 	AudioStream* audioStream;
 	ASPROPERTY_GETTER_SETTER(uint32_t,position);
 public:
-	SoundChannel(Class_base* c, std::streambuf *s=NULL, _NR<Sound> owner=NullRef);
+	SoundChannel(Class_base* c, _NR<StreamCache> stream=NullRef);
 	~SoundChannel();
 	static void sinit(Class_base* c);
 	static void buildTraits(ASObject* o);
diff --git a/src/scripting/flash/net/URLStream.cpp b/src/scripting/flash/net/URLStream.cpp
index 1d3594a..d1bcdc0 100644
--- a/src/scripting/flash/net/URLStream.cpp
+++ b/src/scripting/flash/net/URLStream.cpp
@@ -43,17 +43,19 @@ void URLStreamThread::execute()
 
 	//TODO: support httpStatus, progress events
 
-	if(!createDownloader(false, loader))
+	_R<MemoryStreamCache> cache(_MR(new MemoryStreamCache));
+	if(!createDownloader(cache, loader))
 		return;
 
 	bool success=false;
 	if(!downloader->hasFailed())
 	{
 		getVm()->addEvent(loader,_MR(Class<Event>::getInstanceS("open")));
-		downloader->waitForTermination();
+		cache->waitForTermination();
 		if(!downloader->hasFailed() && !threadAborting)
 		{
-			istream s(downloader);
+			std::streambuf *sbuf = cache->createReader();
+			istream s(sbuf);
 			uint8_t* buf=new uint8_t[downloader->getLength()];
 			//TODO: avoid this useless copy
 			s.read((char*)buf,downloader->getLength());
@@ -61,6 +63,7 @@ void URLStreamThread::execute()
 			data->acquireBuffer(buf,downloader->getLength());
 			//The buffers must not be deleted, it's now handled by the ByteArray instance
 			success=true;
+			delete sbuf;
 		}
 	}
 
diff --git a/src/scripting/flash/net/flashnet.cpp b/src/scripting/flash/net/flashnet.cpp
index 7b268bc..10c408d 100644
--- a/src/scripting/flash/net/flashnet.cpp
+++ b/src/scripting/flash/net/flashnet.cpp
@@ -29,6 +29,7 @@
 #include "backends/audio.h"
 #include "backends/builtindecoder.h"
 #include "backends/rendering.h"
+#include "backends/streamcache.h"
 #include "scripting/argconv.h"
 
 using namespace std;
@@ -304,7 +305,8 @@ void URLLoaderThread::execute()
 
 	//TODO: support httpStatus, progress events
 
-	if(!createDownloader(false, loader, loader.getPtr()))
+	_R<MemoryStreamCache> cache(_MR(new MemoryStreamCache));
+	if(!createDownloader(cache, loader, loader.getPtr()))
 		return;
 
 	_NR<ASObject> data;
@@ -312,10 +314,12 @@ void URLLoaderThread::execute()
 	if(!downloader->hasFailed())
 	{
 		getVm()->addEvent(loader,_MR(Class<Event>::getInstanceS("open")));
-		downloader->waitForTermination();
+
+		cache->waitForTermination();
 		if(!downloader->hasFailed() && !threadAborting)
 		{
-			istream s(downloader);
+			std::streambuf *sbuf = cache->createReader();
+			istream s(sbuf);
 			uint8_t* buf=new uint8_t[downloader->getLength()+1];
 			//TODO: avoid this useless copy
 			s.read((char*)buf,downloader->getLength());
@@ -344,6 +348,7 @@ void URLLoaderThread::execute()
 				assert(false && "invalid dataFormat");
 			}
 
+			delete sbuf;
 			success=true;
 		}
 	}
@@ -683,22 +688,25 @@ void NetConnection::execute()
 	assert(!messageData.empty());
 	std::list<tiny_string> headers;
 	headers.push_back("Content-Type: application/x-amf");
-	downloader=getSys()->downloadManager->downloadWithData(uri, messageData,
-			headers, NULL);
+	_R<MemoryStreamCache> cache(_MR(new MemoryStreamCache));
+	downloader=getSys()->downloadManager->downloadWithData(uri, cache,
+			messageData, headers, NULL);
 	//Get the whole answer
-	downloader->waitForTermination();
-	if(downloader->hasFailed()) //Check to see if the download failed for some reason
+	cache->waitForTermination();
+	if(cache->hasFailed()) //Check to see if the download failed for some reason
 	{
 		LOG(LOG_ERROR, "NetConnection::execute(): Download of URL failed: " << uri);
 //		getVm()->addEvent(contentLoaderInfo,_MR(Class<IOErrorEvent>::getInstanceS()));
 		getSys()->downloadManager->destroy(downloader);
 		return;
 	}
-	istream s(downloader);
+	std::streambuf *sbuf = cache->createReader();
+	istream s(sbuf);
 	_R<ByteArray> message=_MR(Class<ByteArray>::getInstanceS());
 	uint8_t* buf=message->getBuffer(downloader->getLength(), true);
 	s.read((char*)buf,downloader->getLength());
 	//Download is done, destroy it
+	delete sbuf;
 	{
 		//Acquire the lock to ensure consistency in threadAbort
 		SpinlockLocker l(downloaderLock);
@@ -1070,9 +1078,8 @@ ASFUNCTIONBODY(NetStream,play)
 	}
 	else //The URL is valid so we can start the download and add ourself as a job
 	{
-		//Cahe the download only if it is not RTMP based
-		bool cached=!th->url.isRTMP();
-		th->downloader=getSys()->downloadManager->download(th->url, cached, NULL);
+		StreamCache *cache = new FileStreamCache;
+		th->downloader=getSys()->downloadManager->download(th->url, _MR(cache), NULL);
 		th->streamTime=0;
 		//To be decreffed in jobFence
 		th->incRef();
@@ -1232,7 +1239,8 @@ void NetStream::execute()
 
 	//The downloader hasn't failed yet at this point
 
-	istream s(downloader);
+	std::streambuf *sbuf = downloader->getCache()->createReader();
+	istream s(sbuf);
 	s.exceptions(istream::goodbit);
 
 	ThreadProfile* profile=getSys()->allocateProfiler(RGB(0,0,200));
@@ -1349,6 +1357,7 @@ void NetStream::execute()
 		audioStream=NULL;
 	}
 	delete streamDecoder;
+	delete sbuf;
 }
 
 void NetStream::threadAbort()
@@ -1738,8 +1747,7 @@ ASFUNCTIONBODY(lightspark,sendToURL)
 	urlRequest->getPostData(postData);
 	assert_and_throw(postData.empty());
 
-	//Don't cache our downloaded files
-	Downloader* downloader=getSys()->downloadManager->download(url, false, NULL);
+	Downloader* downloader=getSys()->downloadManager->download(url, _MR(new MemoryStreamCache), NULL);
 	//TODO: make the download asynchronous instead of waiting for an unused response
 	downloader->waitForTermination();
 	getSys()->downloadManager->destroy(downloader);
-- 
1.8.5.3

